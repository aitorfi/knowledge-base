---
layout: default
title: Memory leaks
parent: C Programming Language
---

# Memory leaks

C
{: .label .label-blue }

Reference manual
{: .label .label-yellow }

Memory leaks occur when a program allocates memory dynamically but fails to release it when it's no longer needed. Debugging memory leaks in C programs is crucial to ensure that your application doesn't consume excessive memory over time.

## Debugging memory leaks

### Valgrind

@see [Memcheck Command-Line Options](https://valgrind.org/docs/manual/mc-manual.html#mc-manual.options)

Valgrind is a powerful and widely used memory error detection tool that can help identify memory leaks, buffer overflows, and other memory-related issues in C and C++ programs. Following there's a step-by-step guide on how to use Valgrind to debug memory leaks:

- **Installation:** If you do not have Valgrind installed on your machine you can install it using your package manager e.g. `apt` or `brew`.

- **Compile your program:** Compile your program with debugging symbols enabled using the -g compiler flag so that Valgrind can show more detailed error messages.

```bash
gcc -g -o your_program your_program.c
```

- **Run valgrind:** Use the following command to run your program using valgrind. The `--leak-check=<set>` flag enables leak checking, the possible values are `no`, `summary`, `yes` and `full`. The `--show-leak-kinds=<set>` flag indicates the set of leak kinds to be reported when the flag `--leak-check=full` is specified, the possible values are `all`, `none`, `definite`, `indirect`, `possible` and `reachable`.

```bash
valgrind --leak-check=full --show-leak-kinds=all --error-limit=no --log-file=valgrind.log ./your_program
```

- **Analyze the valgrind report:** After running your program with Valgrind, it will provide a report with information about memory leak issues. Here is an example of a report generated by Valgrind:

```
==12345==ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==12345==Leak summary:
==12345==    definitely lost: 16 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

If you are using a library with known memory leaks you can create a suppression file to hide them in the report. To do this run valgrind with the flag `--gen-suppressions=all`, this will generate a suppression for every reported leak, now you just have to copy the suppressions to a file. To instruct valgrind to use a suppression file use the flag `--suppressions=suppression-file`. Here's a sample of a suppression:

```
{
   <insert_a_suppression_name_here>
   Memcheck:Cond
   fun:__GI_strlen
   obj:/usr/lib/libX11.so.6.3.0
   fun:_XlcCreateLocaleDataBase
   obj:/usr/lib/libX11.so.6.3.0
   obj:/usr/lib/libX11.so.6.3.0
   fun:_XlcCreateLC
   fun:_XlcUtf8Loader
   fun:_XOpenLC
   fun:_XlcCurrentLC
   fun:XSupportsLocale
   obj:/usr/lib/libgdk-x11-2.0.so.0.2000.1
   fun:gdk_set_locale
}
```

### AddressSanitizer

AddressSanitizer (ASan) is a memory error detector tool that is part of the Clang and GCC compilers. It is designed to help detect memory leaks, buffer overflows, and other memory-related issues in C and C++ programs. Following there's a step-by-step guide on how to use AddressSanitizer to debug memory leaks:

- **Enable AddressSanitizer:** Compile your C program with the AddressSanitizer instrumentation by using the `-fsanitize=address` flag. Add the `-g` flag to enable debugging symbols too, that way AddressSanitizer will show more detailed error messages.

```bash
gcc -g -fsanitize=address -o your_program your_program.c
```

- **Run the program:** Execute your program as you normally would and if there are memory leaks AddressSanitizer will detect them providing detailed information about the leaks.

- **Analyze the report:** After running your program AddressSanitizer will print a report indicating memory leak issues. The report provides information about the allocated memory and the locations in your code where memory was allocated but not freed. Here is an example of a report generated by AddressSanitizer:

```
==12345==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 4 byte(s) in 1 object(s) allocated from:
    #0 0x7f88de8607e0 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.5+0x107e0)
    #1 0x55555555528f in main your_program.c:6
    #2 0x7f88de5370b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

SUMMARY: AddressSanitizer: 4 byte(s) leaked in 1 allocation(s).
```

### LeakSanitizer

LeakSanitizer (LSan) is a memory leak detection tool that is part of the Clang and GCC compilers. It is designed to help identify memory leaks in C and C++ programs by detecting allocated memory that is not properly deallocated.

{: .warning }
> LeakSanitizer and AddressSanitizer are similar tools, the difference is that LeakSanitizer focuses on memory leak detection and AddressSanitizers detects other memory related errors on top of that.

To use LeakSanitizer compile your program with the flag `-fsanitize=leak` as in the example bellow and follow the same steps as you would using AddressSanitizer.

```bash
gcc -g -fsanitize=leak -o your_program your_program.c
```
